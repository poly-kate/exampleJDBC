<b>Java Persistence API (JPA)</b> - спецификация API Java EE, предоставляет возможность сохранять в удобном виде Java-объекты в базе данных.
Java Persistence API - набор абстракций. JPA реализует концепцию ORM.

<b>ORM (Object-Relational Mapping)</b> - технология программирования, 
которая связывает базы данных с концепциями объектно-ориентированных языков программирования.

<b>Hibernate</b> - одна из самых популярных открытых реализаций спецификации JPA.
То есть JPA описывает правила и предоставляет API для взаимодействия с БД, а Hibernate их реализует.

### Основные понятия JPA и Hibernate:
 
<b>Persistent domain object (entity/сущность)</b> - хранимый объект бизнес логики. 
Нетранзиентные поля сущности должны сохраняться в реляционной базе данных.

<b>MappedSuperclass</b> - класс от которого наследуются entity, он может содержать аннотации JPA, сам такой класс не является entity.

#### Требования к entity-классам:
1. перечисление или интерфейс не могут быть определены как сущность
2. могут быть абстрактными
3. не должны быть final (это необходимо для ленивой загрузки связанных данных)
4. могут расширять обычные Java классы (не entity-классы), а также entity-классы и наоборот
5. должны быть классами верхнего уровня
6. должны быть аннотирован аннотацией javax.persistence.Entity
7. классы должен иметь public или protected конструктор без аргументов, также могут определять дополнительные конструкторы с аргументами
8. должен иметь уникальный идентификатор, аннотированный аннотацией javax.persistence.Id или javax.persistence.EmbeddedId
9. доступ к свойствам должен обеспечиваться через геттеры и сеттеры

#### Допустимые типы атрибутов у entity-классов: 
1. примитивные типы и их классы-обертки 
2. строки
3. BigDecimal и BigInteger
4. java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Time, java.sql.Timestamp
5. перечисления
6. любые типы, имплементирующие Serializable
7. entity-типы
8. коллекции
9. с появлением java 8 появилась возможность использовать классы из пакета java.time
10. [в Hibernate есть возможность использовать org.hibernate.type с аннотацией @Type, а также определять пользовательские типы](https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#basic)

#### Составные первичные ключи:
Если уникальный идентификатор является составным, то он будет определен, как отдельный класс. 

К таким классам предъявляются следующие требования:
1. у класса должен быть публичный конструктор без аргументов
2. необходимо корректно переопределить методы equals и hashCode
3. класс должен реализовывать Serializable интерфейс
4. поля, входящие в состав первичного ключа по умолчанию не могут быть null 

#### Типы связей между Entity:
1. OneToOne -  связь один к одному, один экземпляр entity-класса может связан с одним объектом другого entity-класса. 
Ссылка на связь может быть установлена только с одной стороны
2. OneToMany - связь один ко многим, один объект entity-класса может быть связан с несколькими объектами другого entity-класса
3. ManyToOne - связь многие к одному, обратная связь для OneToMany
4. ManyToMany - связь многие ко многим, несколько объектов entity-класса могут быть связаны с несколькими объектами другого entity-класса

#### Fetch стратегии для извлечения связанных сущностей:
1. LAZY — данные поля будут загружены только во время первого доступа к этому полю
2. EAGER — данные поля будут загружены немедленно

#### Транзакции.
Транзакция - набор операций, которые могут быть либо целиком и успешно выполнены, либо полностью не выполнены.
Оборачивание нескольких операций в одну транзакцию гарантирует, что либо мы выполним все операции, либо ничего не произойдёт.
Hibernate реализует модель транзакций JDBC. 
1. транзакцию можно начать вызовом beginTransaction() объекта Session
2. c объектом Session всегда связан ровно один объект Transaction, доступ к которому может быть получен вызовом getTransaction()
3. метод commit() подтверждает транзакцию
4. метод rollBack() откатывает транзакцию к вызову метода beginTransaction()

#### Cессии.
Cессия (session) используется для получения соединения с базой данных (далее – БД), благодаря сессиям
мы добавляем, обновляем, редактируем и удаляем объекты с помощью.

Интерфейс org.hibernate.Session является мостом между приложением и Hibernate.

Объект типа Session получают из экземпляра типа org.hibernate.SessionFactory, который должен присутствовать в приложении 
в виде singleton.

В рамках одной сессии может быть несколько транзакций БД.

Необходимо контролировать закрытие объекта сессии. 
Для многопоточной среды правильно создавать новый объект сессии для каждого запроса.

#### Состояния экземпляра класса-сущности:
transient object - новый экземпляр класса-сущности, который еще не был привязан ни к одной сессии
persistent object - переходный экземпляр класса-сущности, связан с уникальной сессией
detached object - объект был (persistent) связан с сессией, но больше таковым не является

#### Методы, используемые для добавления записи, обновления записи, удаления записи, извлечения записи:
1. Методы, которые используются для добавления в таблицу: persist() и save()
2. Методы, которые используются для обновления данных в таблице: save() и merge()
3. Методы, которые используются для удаления записей: delete()
4. Методы, которые используются для получения данных из БД: get() и load()


Методы save(), persist(), saveOrUpdate() переводят объект из состояния transient в состояние persistent
Методы get(), load() возвращают persistent объекты.

Методы update(), saveOrUpdate() переводят объект из состояния detached в состояние persistent.
Метод merge() возвращает новый объект в состоянии persistent

##### Различия между persist() и save():
1. persist() описан в спецификации; save() оригинальный метод hibernate
2. persist() - void метод; save() возвращает Serializable первичный ключ
3. persist() гарантирует, что он не будет выполнять оператор INSERT, если он вызывается вне границ транзакции;
save() не гарантирует этого, он возвращает идентификатор, и если для получения идентификатора необходимо выполнить вставку (например, генератор "identity"), 
эта вставка происходит немедленно, независимо от того, находитесь ли вы внутри или снаружи транзакции.
4. persist() для detached объекта приведет к PersistentObjectException; save() для detached объекта приведет к добавлению записи в таблице
5. Вызов save() без транзакции, может привести к получению несогласованных данных, не подходит для длительных сессий. 

##### Различия между save() и merge():
1. merge() описан в спецификации; update() оригинальный метод hibernate
2. 

        Session session = HibernateUtils.getSessionFactory().openSession(); // старт сессии #1
        session.beginTransaction(); // начало транзакции
        
        Message message = new Message(); // статус объекта transient
        Message.MessageKey key = new Message.MessageKey();
        key.setAuthorName("Автор");
        key.setAuthorSurname("Фамилия");
        message.setText("текст сообщения");
        message.setSent(LocalDateTime.now());
        message.setKey(key);
        session.persist(message); // добавление объекта в таблицу,
        // с сессией #1 ассоциирован объект Message с первичным ключом key
        session.getTransaction().commit(); // подтверждение транзакции
        session.close(); // закрытие сессии #1
        
        message.setText("новый текст сообщения"); // изменение каких либо характеристик объекта
        
        session = HibernateUtils.getSessionFactory().openSession(); // старт сессии #2
        session.beginTransaction(); // начало транзакции
        
        Message messageFromDB = session.get(Message.class, key); // получение записи из таблицы по первичному ключу key,
        // с сессией #2 ассоциирован объект Message с первичным ключом key
        
        // обновление записи методом update приведет к Exception, тк с данной сессией уже ассоциирован объект
        // с первичным ключом key (объект messageFromDB)
        session.update(message);
        
        // обновление записи методом merge приведет к слиянию характеристик текущего объекта с предыдущими изменениями объекта
        session.merge(message); // текст messageFromDB: новый текст сообщения
        
        session.getTransaction().commit(); // подтверждение транзакции
        session.close(); // закрытие сессии #2


#### Блокировки:
Это механизм, позволяющий параллельную работу с одними и теми же данными в базе данных. 
Когда более чем одна транзакция пытается получить доступ к одним и тем же данным в одно и то же время, в дело вступают блокировки, 
которые гарантируют, что только одна из этих транзакций изменит данные. 

Существует два основных подхода к блокированию транзакций: оптимистичный и пессимистичный.

#####  Оптимистичный подход (блокирование выполнено на уровне Hibernate, а не базы данных)
Предполагается, что араллельно выполняющиеся транзакции редко обращаются к одним и тем же данным и позволяет им спокойно и свободно выполнять любые чтения и обновления данных. 
Но при записи данных в базу, производится проверка, изменились ли данные в ходе выполнения данной транзакции и если да, транзакция обрывается и выбрасывается исключение. 

Для поддержки таких блокировок в класс добавляется поле версии, которое анализирует Hibernate при сохранении изменений.
@Version private long version; Hibernate разрешает доступ к объектам все транзакциям сразу,
но при сохранении объектов проверяет, нет ли изменений, внесённых другими транзакциями. 
В случае, если обнаружится конкурирующее изменение, транзакция откатывается.
Поле может быть целочисленным или датой.

Режимы блокировок:

    LockModeType.OPTIMISTIC
    LockModeType.OPTIMISTIC_INCREMENT
    LockModeType.READ

##### Оптимистичный подход (блокирование выполняется на уровне базы, hibernate не добавляет дополнительную семантику, он использует только то, что доступно в данной СУБД)
Пессимистичный подход ориентирован на транзакции, которые постоянно или часто конкурируют за одни и те же данные 
и поэтому блокирует доступ к данным, в тот момент когда читает их. Другие транзакции останавливаются, 
когда пытаются обратиться к заблокированным данным и ждут снятия блокировки (или выбрасывают исключение).

Блокировка в случае пессимистичного блокирование всегда запрашивается для конкретного объекта во время его загрузки или позднее:

Режимы блокировок:

    LockMode.PESSIMISTIC_READ — данные блокируются в момент чтения и это гарантирует, что никто в ходе выполнения транзакции 
    не сможет их изменить. Остальные транзакции, тем не менее, смогут параллельно читать эти данные. 
    LockMode.PESSIMISTIC_WRITE — данные блокируются в момент записи и никто с момента захвата блокировки не может в них писать 
    и не может их читать до окончания транзакции, владеющей блокировкой. 
    
    LockMode.PESSIMISTIC_READ может поддерживаться не всеми базами данных и в этом случае автоматически будет применён LockMode.PESSIMISTIC_WRITE

    Object o = session.load(Object.class, pk, LockMode.PESSIMISTIC_READ);
    Object o = session.get(Object.class, pk, LockMode.PESSIMISTIC_READ);
    
    session.lock(someObj, LockMode.PESSIMISTIC_WRITE)

#### Уровни изоляции транзакций:
<b>Грязное чтение</b> - транзакция при выполнении последовательных чтений объекта читает так же и изменения, вносимые другими транзакицями, 
но ещё даже не подтверждённые (commit). Эти изменения могут пропасть при откате других транзакций. 
То есть, когда одна транзакция меняет сущность, вторая транзакция при чтении этой сущности из базы сразу увидит изменение, 
даже если первая транзакция впоследствии откатится.

<b>Неповторяемое чтение</b> - транзакция при выполнении последовательных чтений объекта читает изменения внесёнными другими, 
уже подтверждёнными и закончившимися транзакциями. То есть, если одна транзакция прочитала сущность, потом другая транзакция 
её обновила и успешно завершилась, то первая транзакция, если прочитает сущность ещё раз, увидит уже обновлённые данные.

<b>Фантомное чтение</b> - транзакция при выполнении последовательных выборок строк по одним и тем же критериям получает 
каждый раз разный список строк, в которым попадают строки, добавленные другими, уже подтверждёнными и закончившимися транзакциями. 
То есть, если транзакция загружает список сущностей один раз, а в это время другая транзакция создаёт в базе новую сущность, 
то при повторной загрузке этого списка транзакция увидит и новую сущность тоже. 

Уровня изоляции транзакций, в которых данные эффекты могут происходить:
1. Serializable — транзакции полностью изолируются друг от друга и ни одна транзакция ни коим образом не влияет на другие. Самая низкая степень параллельности транзакций.
2. Repeatable Read — изменения данных, которые были прочитаны в транзакции ранее в транзакцию не попадают, 
другие транзакции не могут изменять данные, прочитанные этой транзакцией. Возможен эффект фантомного чтения, 
степень параллельности транзакций выше, чем у Serializable.
3. Read Сommited (используется по умолчанию большинством СУБД) — транзакции получают изменения в данных от других транзакций, 
которые были успешно подтверждены. Возможны эффекты фантомного чтения и неповторяемого чтения.
 Этот уровень изоляции обычно используется по умолчанию 
4. Read Uncommited — самый низкий уровень изоляции транзакций, который гарантирует только, что изменения, внесённые одной транзакцией, 
не будут перезаписаны другой транзакцией. Обеспечивает наивысшую степень параллельности транзакций.

Установка уровня изоляции в файле с настройками:

    <property name="connection.isolation">1</property>
    1 - Read uncommitted isolation 
    2 - Read committed isolation (возможно грязное чтение)
    4 - Repeatable read isolation (возможны грязное чтение, неповторяемое чтение)
    8 - Serializable isolation (возможны грязное чтение, неповторяемое чтение, фантомное чтение)

Аннотации JPA и Hibernate

